---
layout: post
title: 深入剖析Win32可移植可执行文件格式第一部分（原文：An In-Depth Look into the Win32 Portable Executable File Format）
category: 操作系统
tags: PE，Win32，exe，dll
description: PE文件介绍
---
>原文的一个翻译，译者：SmartTech。[原文地址](https://msdn.microsoft.com/en-us/magazine/bb985992.aspx)。

作者:Matt Pietrek  
本文假设你对C++和Win32平台熟悉，[PE.exe](http://download.microsoft.com/download/msdnmagazine/code/Feb02/WXP/EN-US/PE.exe)

## 总结
对可移植执行体文件（PE）形式的好的一个理解会使得对操作系统有一个好的理解。如果你知道你的DLL和EXE文件中有些什么，那么你将是一个更有见识的程序员。这篇文章，也是两篇连载中的第一篇，着眼于在过去的几年间PE文件格式发生的改变，以及对其格式的一个概述。

这次更新之后，作者讨论了PE格式是如何满足.NET应用，PE文件部分，RVAs，数据路径，以及函数的引入。附录包含了一份相关镜像头结构和他们描述的清单。


## 正文
很久以前,我开始为Microsoft Systems Journal(现在的MSDN® Magazine)写文章,其中有一篇名为“探索PE文件内幕——Win32 可移植可执行文件格式之旅”的文章很受欢迎,大大超出了我的意料。直到现在,我还听说有人（甚至在Microsoft）仍然在使用那篇文章,它依旧被 收录在MSDN Library中。不幸的是,文章的最大问题是它们是静止的。但是Win32®的世界在这些年已经发生了很大的变化,因此那篇文章已经严重过时了。我要从本月开始用两部分系列的文章 来补救这种情况。

你可能想知道为什么要关注可执行文件的格式。答案永远是:操作系统的可执行文件格式和数据结构展现了操作系统内部许多信息。通过理解EXE和DLL的内部情况,你会发现你已经变成你周围一个更优秀的程序员。

当然,通过阅读 Microsoft 的 PECOFF 规范你可以获得许多我将要告诉你的内容。但是与大多数规范一样,它更注重完整性而不是可读性。在本文中,我把精力集中于解释整个主题中最重要的部分,同时填补那些并不适合出现在官方规范中的怎么样（How）以及为什么（Why）的问题。另外,在本文中我还会讲到一些非常有用的内容,它们并未出现在任何 Microsoft 官方文档中。

### 背景知识

让我先举一些例子来说明自从1994年我写那篇文章以来有关可执行文件方面都发生了哪些变化。由于16位Windows®已经成为历史,因此没有必要再与Win16的NE（New Executable）格式相比较了。另一个已经脱离人们视野的是Win32s®。在 Windows 3.1 上运行Win32 程序非常不稳定是最令人讨厌的事。

回到当时,Windows 95(当时代号为“Chicago”)甚至还未发行。Windows NT®还是3.5版。Microsoft 链接器还未进行非常有效地优化。值得一提的是当时已经在MIPS和DEC Alpha 上实现了 Windows NT。

自从那篇文章以来都出现了什么新内容呢?64位Windows引进了它自己的变种的PE文件格式。Windows CE 添加了许多的新型处理器。诸如DLL延迟加载、节合并以及绑定之类的优化已经铺天盖地。有许多新东西要加入到这个故事中。

让我们不要忘了 Microsoft® .NET。该把它放在什么位置呢?对于操作系统来说,.NET可执行文件只不过是普通的Win32可执行文件。但是.NET运行时能够识别出这些可执行文件中的数据并把它作为元数据(metadata)和中间语言(Intermediate Language,IL),它们对.NET来说非常重要。在本文中,我要敲开.NET元数据结构的大门,但把对它全部光彩的彻底挖掘留 给下一篇文章。

如果Win32世界中的所有这些加加减减还不足以成为我重新写那篇文章的理由的话,那么我只有列出原来那篇文章中的一些令我害怕的错误了。例如我对线程局部存储(TLS)支持情况的描述是错误的。同样,通篇我对日期/时间戳这个DWORD的描述仅在太平洋时区才是精确的!

另外,有许多内容在当时是正确的,但现在已经不正确了。我说过.rdata节并没有太大的作用。今天,诚然是这样。我也说过.idata节是可读/可写的节,但现在却有许多试图拦截API的人发现它在很多情况下都是不正确的。

伴随着在这篇文章中完全更新PE文件格式的故事,我也对用于显示PE文件内容的PEDUMP程序进行了彻底修改。PEDUMP现在可以在x86和IA-64平台上编译和运行,并且能够转储32位和64位PE文件。最重要的是,PEDUMP的源代码可以从本文开头的链接处下载。这样,你就有了一个用这里讲的概念和数据结构实际工作的例子。

### PE文件概览

Microsoft引进了PE文件格式,更经常被称为PE格式,作为最初的Win32规范的一部分。然而PE文件源自VAX/VMS上早期的通用目标文件格式(Common Object File Format,COFF)。这是由于许多最初的Windows NT 开发团队的成员都来自数字设备公司(Digital Equipment Corporation,DEC)。这些开发者很自然就使用现有的代码以便快速开始新的 Windows NT 平台。

之所以选择术语“可移植可执行”是打算要在所有支持的CPU上的所有版本的Windows上使用相同的可执行文件格式。从大的方面来说,这个目标已经实现,因为Windows NT及其后继操作系统、Windows 95及其后继操作系统以及 Windows CE都使用相同的可执行文件格式。

Microsoft编译器生成的OBJ文件也使用COFF格式。从COFF格式的一些域使用的竟然是八进制编码你就能知道它是多么老。COFF格式的OBJ文件中有许多数据结构和枚举类型与PE文件相同,后面我会提到。

64位Windows需要做的只是修改PE格式的少数几个域。这种新的格式被称为PE32+。它并没有增加任何新域,仅从PE格式中删除了一个域。其余的改变就是简单地把某些域从32位扩展到64位。在大部分情况下,你都能写出同时适用于32位和64位PE文件的代码。Windows头文件有这种魔力可以使这些区别对于大多数基于C++的代码都不可见。

EXE文件与DLL文件的区别完全是语义上的。它们使用的是相同的PE格式。惟一的不同在于一个位,这个位用来指示文件应该作为EXE还是DLL。甚至DLL文件的扩展名也完全也是人为的。你可以给DLL一个完全不同的扩展名,例如.OCX控件和控制面板小程序(.CPL)都是 DLL。

PE文件一个非常好的地方就是它的数据结构在磁盘上与在内存中一样。加载一个可执行文件到内存(例如通过调用 LoadLibrary 函数)主要就是把PE文件中的某个部分映射到地址空间中。因此像IMAGE_NT_HEADERS(后面我会讲到)这样的数据结构在磁盘上和在内存中是一样的。如果你知道如何在一个PE文件中找到某些内容,你几乎可以确定当文件被加载进内存时可以找 到同样的信息。

注意到PE文件并不是作为单一的内存映射文件被映射进内存的这一点非常重要。相反,Windows加载器查看PE文件并确定文件中的哪些部分需要被映射。当映射进内存时,文件中的高偏移相对于内存中的高地址。某项内容在磁盘文件中的偏移可能与它被加载进内存之后的偏移不同,但是将磁盘文件中的偏移转换成内存偏移需要的所有信息都存在(见下图)。

　　　　　　　　　　　  ![2016-12-16-1](/public/img/2016-12-16-introduction-1.png)

当PE文件由Windows加载器加载进内存时,它在内存中被称为模块(module)。文件被映射到的内存的起始地址被称为 HMODULE。这是需要记住的一点:给你一个HMODULE,你就知道在那个地址处到底有什么样的数据结构,并且你可以根据PE文件的知识找到内存中所有其它的数据结构。这个强大的功 能 可 以 被 用 作 其 它 用 途 ,例如拦截 API。(说得再准确一点,在Windows CE上HMODULE与加载地址并不相同,但那不是今天要讨论的内容。)

内存中的模块代表一个进程所需的可执行文件中的所有代码、数据和资源。PE文件中的其它部分可能会被读取,但并不被映射进内存(例如重定位节)。一些部分可能根本就不被映射,例如放在文件末尾的调试信息。PE文件头中的一个域告诉系统将这个可执行文件映射进内存时需要占用多少内存。不被映射的数据放在文件末尾,位于所有需要被映射的部分之后。









    

















