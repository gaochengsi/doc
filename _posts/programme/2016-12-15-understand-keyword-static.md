---
layout: post
title: 理解static关键字
category: 编程
tags: 编程，静态，static
description: 理解static关键字在编程中的作用。
---
>总结下static关键字在常见语言中的作用。

## C语言

### 1.static使的函数内部的局部变量的值持久化，也就是说当再一次调用该函数时，该变量的值会是上一次调动该函数退出时的值(仍是局部变量)。
example：

```c
#include <stdio.h>
void foo()
{
    int a = 10;
    static int sa = 10;
    a += 5;
    sa += 5;
    printf("a = %d, sa = %d\n", a, sa);
}

int main()
{
    int i;
    for (i = 0; i < 10; ++i)
        foo();
}
```

result:

```c
a = 15, sa = 15
a = 15, sa = 20
a = 15, sa = 25
a = 15, sa = 30
a = 15, sa = 35
a = 15, sa = 40
a = 15, sa = 45
a = 15, sa = 50
a = 15, sa = 55
a = 15, sa = 60
```

当你想让局部变量在函数的多次调用之间保持不变，而你又不想使用全局变量，那么这会是一个很好的办法，但也要注意，不要乱用这个特性，因为它会使得你的代码在多线程下不安全，并且晦涩难懂。
使用了static关键字后会将变量存放在静态分配内存区(全局数据区)而不是自动分配内存区(堆栈区)。尽管编程语言没有写出何种内存来实现，但静态分配内存区通常会在编译时保留在程序的数据段，然而自动分配内存区通常以临时栈来实现，随着程序退出函数体，系统就会收回栈内存。

### 2.static关键字使得全局变量或者函数只能在本文件中调用，而在其他文件中不可见，即使使用了extern也不可调用。
example:

```c
//Example2
//File1第一个代码文件的代码
#include<iostream.h>
void fn();  //声明fn函数
static int n;  //定义静态全局变量
void main()
{
    n=20;
    cout<<n<<endl;
    fn();
}
//File2第二个代码文件的代码
#include<iostream.h>
extern int n;
void fn()
{
    n++;
    printf("%d",n);
}
```

编译运行时，第二个文件会出现错误，但将File1中static关键字去掉，使得n变为全局变量，那么就可以正常的运行。

## C++
static在C++中，除了拥有和C一样的作用外，还可以用在类中，用于定义类中的成员(数据和函数)。

### 1.静态数据成员
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。先举一个静态数据成员的例子。
example:

```c++
#include<iostream>
using namespace std;
class Myclass
{
    public:
        Myclass(int a,int b,int c);
        void GetSum();
    private:
        int a,b,c;
        static int Sum;//声明静态数据成员
};
int Myclass::Sum=0;//定义并初始化静态数据成员
 
Myclass::Myclass(int a,int b,int c)
{
    this->a=a;
    this->b=b;
    this->c=c;
    Sum+=a+b+c;
}
void Myclass::GetSum()
{
    cout<<"Sum="<<Sum<<endl;
}
int main()
{
    Myclass M(1,2,3);
    M.GetSum();
    Myclass N(4,5,6);
    N.GetSum();
    M.GetSum();
}
```

result:

```c++
Sum=6
Sum=21
Sum=21
```

对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；

静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 中，语句int Myclass::Sum=0；是定义静态数据成员；

静态数据成员和普通数据成员一样遵从public,protected,private访问规则；

因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；

静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
数据类型 类名::静态数据成员名=值

类的静态数据成员有两种访问形式：
类对象名.静态数据成员名 或 类类型名::静态数据成员名
如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员;
静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；

同全局变量相比，使用静态数据成员有两个优势：
静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能。

### 2.静态成员函数

与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部 实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。
example:

```c++
#include <iostream>
using namespace std;
class Myclass
{
    public : 
        Myclass(int a,int b,int c);
        static void GetSum(); // 声明静态成员函数
    private : 
        int a, b, c;
        static int Sum; //声明静态数据成员
};
int Myclass::Sum=0; //定义并初始化静态数据成员
Myclass::Myclass(int a,int b,int c)
{
    this->a = a;
    this->b = b;
    this->c = c;
    Sum += a + b + c; //非静态成员函数可以访问静态数据成员
}
void Myclass::GetSum() //静态成员函数的实现,不用加static
{
    // cout<<a<<endl; //错误代码，a是非静态数据成员
    cout<<"Sum="<<Sum<<endl;
}
int main()
{
    Myclass M(1,2,3);
    M.GetSum();
    Myclass N(4,5,6);
    N.GetSum();
    Myclass::GetSum();
}
```

result:

```c++
Sum=6
Sum=21
Sum=21
```

关于静态成员函数，可以总结为以下几点：
出现在类体外的函数定义不能指定关键字static；
静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
非静态成员函数可以任意地访问静态成员函数和静态数据成员；
静态成员函数不能访问非静态成员函数和非静态数据成员；
由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
调用静态成员函数，可以用成员访问操作符（.）和（->；）为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
<；类名>::<；静态成员函数名>；（<；参数表>；）
调用类的静态成员函数。
作用
static静态变量声明符。在声明它的程序块，子程序块或函数内部有效，值保持，在整个程序期间分配存储器空间，编译器默认值0。
是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。















